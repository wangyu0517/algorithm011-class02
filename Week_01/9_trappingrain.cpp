/**
思路:这种题，真实目的隐藏的很深，一眼看去无从下手，没做过就只能慢慢尝试推导。特殊规律那种，没做过基本不可能解出来。目测这个题还能自己慢慢推导。
下面开始推导-----
通常需要问题转换，把一个问题转换成另外一个问题，或者说给问题做另外一个数学描述。
对比开始状态和结束状态，可以发现是去掉了凹形结构，最终达到一个凸形结构。
1、凸形结构特点，以原本的最高点为基础，向两边扩散，填平凹的地方。那么最外层我们可认为是一个扩散循环，直到扩散到边界为止。
2、补凹形，这个操作可认为是原始素据+1。总共加1的次数，即为最后的水单位数
3、补凹形的判断条件。最高点向左扩散，必须是递减序列，如果发现当前比前一个大，需要回退到前一个点，补上差值，然后继续迭代往后补，直到补到最高点。
   这个逻辑是很简单的，但是会发生回退。
4、针对回退的重复遍历进行优化。一般带有方向性的遍历，不同方向遍历会有不同的复杂度，可能是正向好，也可能是反向好
假设已经知道最高点位置，我们从旁边2个地方进行夹逼（扩散的反向遍历）。这样避免重复遍历，目测是n次遍历就能完成。同时更好理解。
5、那么总结上面的推导过程，我们可以知道，最终问题转换为：已知有n个元素的数组，其中的最大值位置k，分别以最小的代价将[0,k]和[k,n-1]变成递增和递减序列。
  代价描述：只能把元素增大或者不变，增量越小，代价越小。
6、由5可知，必须要先计算最高点位置，那么需要遍历得到最高点。能否进行优化？
优化思路：5是将原本问题分割成2个不相干的子问题，如果不进行分割，也就是不进行静态的夹逼（需要知道最高点位置，提前求解），换成动态夹逼（左右夹逼过程中，动态更新最高点）
动态夹逼条件：变成双指针问题，左右夹逼通过双指针找到最大值，并且让指针走过的位置保持为递增路径


最后：
改个自己取得数学名字：求数组的最小代价凸形序列。
前面推导过程算法就不写了，直接写最后优化完的算法
**/
class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0;
        int right = height.size()-1;
        int cost = 0;//代价
        while(left < right)//双指针夹逼相遇条件
        {
            if(height[left] < height[right])//始终动小的指针，动态维护最高点。
            {
                int diff = height[left] - height[left+1];
                if(diff > 0)
                {
                    height[left+1] = height[left];
                    cost += diff;
                }
                left++;

            }
            else
            {
                int diff = height[right] - height[right-1];
                if(diff > 0)
                {
                    height[right-1] = height[right];
                    cost += diff;
                }
                right--;
            }
        }
        return cost;
    }
};

//最后查看官方最佳解也是这个。关键是掌握动态更新条件。细微区别在于max函数代替if。个人认为if更好理解一点，max代码简单一点