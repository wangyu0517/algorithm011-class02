极客大学训练营，第一周学习总结

1、学习方法。自己本来是抱着一个督促自己按时按量学习示算法的目的，才参加了本次的极客大学算法训练营。在看覃超老师视屏之前，自己也预想过本次算法会是怎样的一个过程，是高大上very hard?还是平平无奇的just practice，结果都不是，仅仅看了开篇的如何高效的学习方法介绍，就已经是惊艳到我了。下面总结关于这部分的学习心得。
      速度和效率。如何提高学习的速度和效率？首先从看视屏开始，千万不要像看电视剧一样，原速播放。为什么这么说？一方面视屏教程是针对所有人制作的，但是实际上因为每个人的基础程度不一样，有些容易理解的完全可以倍速播放，既能锻炼自己对关键内容的提取能力，又节约了时间，可谓是两全其美。另外一点，快速播放，能够提升和锻炼部分人的大脑专注程度，high speed 能够让我们思维更加兴奋活跃。ps:习惯老师的语速，享受专注，并渐渐成为一个专业人士。
      刷题方法。不要死磕，不要死磕，不要死磕，重要的事情说3遍。想到之前自己刷算法题，常常会死磕，真的就对号入座上了，这个坏习惯一定要改掉，完全就是一种思维误区。另外就是“五毒神掌”，遍数很重要，从高中到大学，最重要的学习方式就是刷题，没有之一。我们是来学习算法的，不是来发明算法的，只有先学会，才有资格谈创造，学习别人的算法和思想没什么好丢人的。具体的细节刷题方法看老师视屏即可，方法简单粗暴，高效利用时间，能坚持就一定能成功。另外附上b站另外一位up主的学习方法视屏，基本理念和覃超老师的理练一模一样，同时也侧面证实了这种高效学习方法是完全有效的。链接地址：https://www.bilibili.com/video/BV1qi4y1s7wM
     职业化训练。本次算法训练，也是一种职业化训练。要想在某一领域成为top20 或者 top10，一定要靠专业的训练。老师也给出很多职业选手的训练方法视频，那些最终成就瞩目的，都是从基础动作分解，不断练习做起，可以说如果不刻意去练习，是很难达到顶尖水准的。基础不好？那么就不断分解和练习。


2、刚好赶上本次端午节休息，所以我在家花了一天时间认真上完week1的课程并完成作业，下面是我挑的一个课后作业，总结一下解题思路和方法。

      首先本周的作业，偏向于数组操作。数组操作大部分分为1、使用辅助结构，栈、map等 2、原地操作，基本都是考查双指针熟练度。拿到一个算法题，我们该如何进行解题呢？下面我给出结合老师的思维方式和我自身情况的解题思路。
      审题。先给题目定性。什么是定性？定性就是先搞清楚题目的表达意思，搞清楚题目可能考查的数据结构等等。比如“接雨水”爬楼梯“等等这些，给的是实际场景，没有给数学上代码上最直白的题目表示，那么这种情况我们就需要准确分析题目意思，并且转为容易理解和实现的数学表达方式。如果是直白的那种题目，这个一般都简单，不会做肯定是刷的太少。
      分类。确定题目考查的目的。考查角度，目前我分为怎么几点：1、考查数学能力，需要固定算法求解，这种没做过的，不可能做得出来，用老师的话说，能自己想出来都能拿图灵奖了。这种直接放弃去看答案。 2、考验推导能力，找规律能力。题目存在递推关系，一般都是考查递推能力，需要自己求递推公式，通项公式，方便求解。常用方法就高中数学的递推法找规律。经常一个题推导到最后就变成一个菲波拉契数。3、由暴力解法，衍生其优化方法。暴力算很简单，但是要你优化，主要考察你的优化思想。先暴力求解，在根据暴力中的性能关键点进行优化。4、直白的考察某个算法或者数据结构，这种题目已经很明确告诉你用什么数据结构和算法。只能靠练习  5、和前面直白的题目相反，这种题目出的拐弯抹角，让人搞不清真实意图，考察的还是理解题意，将题意转为现有的数据结构或者算法模型，最后你可能会发现，题目看起来很难，解答确很简单，差不多就是这种情况。
       层次。稍微复杂一点点的算法都有一个层次性，或者递归性。经过前面2部分分析，到这里我们要真正开始写代码了，记住一点，所有的算法都离不开循环，所有的递归也都基本能展开变成循环。确定最外层的遍历循环是重重之重。外层循环是大方向，即使你不能一次性想通实现方法，也能够从外到内层层深入达到最终目的。这个也是老师之前说过的优秀代码结构，由外到内，自顶向下编程，这个方法对解题思想也同样适用。

      按照老师的视频习惯，我所有代码也都写上了自己的基本思路，这里总结分享最后一题的解答思路。原题：接雨水

给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 

1）先思考：这种题，不怎么直白，一眼看去无从下手，之前没做过就只能慢慢尝试推导。特殊规律那种，没做过基本不可能解出来。目测这个题还能自己慢慢推导。猜想应该不难，关键还是转换题意，自己大概能接出来，下面开始推导。
2）这样的题目通常需要问题转换，把一个问题转换成另外一个问题，或者说给问题做另外一个数学描述。因为第一眼就看到了一个水坑是凹形，我瞬间就想到了，在数学里凹形有很多用处，那就先从这个地方开始分析吧。对比开始状态图形和结束状态图形，可以发现是去掉了凹形结构，最终达到一个凸形结构，也就是填坑，把图形变成凸形。
3）、凸形有什么结构特点？最高点往两边都是递减（这里我想到了下楼梯，然后就是梯度下降算法，虽然和这个没关系，记录一下当时的思维还是很有意思的，思维居然飞到了machine learn的梯度下降）。以原本的最高点为基础，向两边扩散，填平凹的地方。那么自此我确定了算法最外层循环，最外层我们可认为是一个扩散循环，从最高点开始，朝着2边遍历，直到扩散到边界为止。
4）、补凹形，前面我已经确定了外层循环，那么在循环的过程中，怎么判断凹的地方，并且填平呢？这个很简单，扩散的过程中，当前元素比上次元素要大，说明是凹形，他们的差值就是要填充的值，每次发现凹形就填平，填充数即为最后的水单位数。
5）、填充问题。补凹形的判断条件。最高点向左扩散，必须是递减序列，如果发现当前比前一个大，需要回退到前一个点，补上差值。当退到前一个点，补上差值后，它可能又无法保证比上一个小了，就需要继续迭代往后比较，直到比较到最高点。这个逻辑是很简单的，但是会发生回退。回退会导致重复遍历。
6）、针对回退的重复遍历进行优化。一般带有方向性的遍历，不同方向遍历会有不同的复杂度。可能是正向好，也可能是反向好。假设已经知道最高点位置，我们从旁边2个地方进行夹逼（扩散的反向遍历）。这样避免重复遍历，目测是n次遍历就能完成，同时更好理解。优化：将原来的扩散改为夹逼。
7）、那么总结上面的推导过程，我们可以知道，问题转换为：已知有n个元素的数组，其中的最大值位置索引为k，分别以最小的代价将[0,k]和[k,n-1]变成递增和递减序列。代价描述：只能把数组中的元素增大或者不变，增量越小，代价越小。
8）、根据7的题意，必须要先计算最高点位置，分段遍历到最高点。能否进行优化？
9）、第8步是将原本问题分割成2个不相干的子问题，如果不进行分割，也就是不进行静态的夹逼（需要知道最高点位置，提前求解，最高点已知所以是静态的），换成动态夹逼（左右夹逼过程中，动态更新最高点）
动态夹逼条件：变成双指针问题，两个指针相向出发，左右夹逼，通过比较双指针的值大小，保持值较大的指针位置不变，始终移动值较小的指针，并且让指针走过的元素值保持为递增（补差值）。

10）、总结。到这里最后思路就很清晰了，很容易写代码了。这里改个自己取得直白数学名字：求数组的最小代价凸形数组。（起了这个名字，是不是可以再来个求数组的最小代价凹形数组？）求前面推导过程算法就不写了，直接写最后优化完的算法。

class Solution {
public:
    int trap(vector<int>& height) {
        int left = 0;
        int right = height.size()-1;
        int cost = 0;//代价
        while(left < right)//双指针夹逼相遇条件
        {
            if(height[left] < height[right])//始终动小的指针，动态维护最高点。
            {
                int diff = height[left] - height[left+1];//计算高度差
                if(diff > 0)
                {
                    height[left+1] = height[left];//填平
                    cost += diff;//记录填充代价
                }
                left++;

            }
            else
            {
                int diff = height[right] - height[right-1];
                if(diff > 0)
                {
                    height[right-1] = height[right];
                    cost += diff;
                }
                right--;
            }
        }
        return cost;
    }
};

//最后查看官方解也是这个。关键是理解题意，双指针和掌握动态更新条件。细微区别在于官方解答用max函数代替if(diff > 0)。个人认为if更好理解一点，max代码简单一点

